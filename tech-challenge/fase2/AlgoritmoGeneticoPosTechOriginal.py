# -*- coding: utf-8 -*-
"""Convertendo_para_Classe.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lNtICzIZZ_eSQma0l849hg6M6AOUEpid
"""
###
## Baseado no algoritmo genético do Prof. Eng. Rodrigo Vertulo
###
import random

class AlgoritmoGeneticoPosTech:
    def __init__(self, tPopulacao, qtdGenes, tMutacao, tElitismo):
        self.tPopulacao = tPopulacao
        self.qtdGenes = qtdGenes
        self.tMutacao = tMutacao
        self.tElitismo = tElitismo

    ##
    # Essa rotina é responsável pela criação de cromossomos.
    # A rotina recebe como parâmetro nGenes que representa
    # a quantidade de genes presentes no cromossomo.
    ##
    def criaCromossomo(self, nGenes):
        cromossomo = ""

        for i in range(nGenes):
            gene = str(random.randint(0, 1))
            cromossomo = str(cromossomo) + str(gene)

        return cromossomo

    ##
    # Essa rotina cria uma população inicial de cromossomos.
    # A rotina recebe como parâmetros os valores nCromossomos, que
    # indica a quantidade de indivíduos contidos na população e
    # também nGenes, que informa a quantidade de genes que cada
    # cromossomo possui.
    ##
    def criaPopulacao(self, nCromossomos, nGenes):
        populacao = []

        for i in range(nCromossomos):
            cromossomo = self.criaCromossomo(nGenes)
            populacao.append(cromossomo)

        return populacao

    ##
    # Essa rotina recebe um cromossomo e a quantidade de dígitos
    # de cada subgrupo de genes a serem extraídos. O retorno da
    # rotina é uma lista contendo todos os subgrupos obtidos.
    ##
    def leituraDeValores(self, cromossomo, tCadeia):
        grupo = []

        subgrupos = []
        valor = ""
        for i in range(1, len(cromossomo)+1):
            valor = str(valor) + str(cromossomo[i-1])
            if i % tCadeia == 0:
                subgrupos.append(valor)
                valor = ""

        return subgrupos

    ##
    # Converte uma lista contendo cadeias de strings binárias em outra
    # contendo números decimais correspondentes a cada string binária
    # original. Recebe o parâmetro lsBinaria e devolve a lista com
    # números decimais.
    ##
    def getDecimal(self, lsBinaria):
        valoresDecimais = []

        for i in lsBinaria:
            valoresDecimais.append(int(i, 2))

        return valoresDecimais

    ##
    # Recebe um cromossomo e calcula a sua nota de aptidão;
    # A rotina devolve uma lista contendo dois elementos, sendo o primeiro deles
    # o próprio cromossomo avaliado e o segundo é a sua nota de aptidão.
    ##
    def fitness(self, cromossomo):
        pass

    ##
    # Recebe dois cromossomos e devolve aquele que possui maior nota de aptidão.
    # O cálculo da nota de aptidão é feito utilizando-se a função fitness.
    ##
    def selecionaIndividuo(self, cromossomo1, cromossomo2):
        if (self.fitness(cromossomo1))[1] > (self.fitness(cromossomo2))[1]:
            return cromossomo1
        else:
            return cromossomo2

    ##
    # Recebe dois cromossomos e retorna um novo gerado a partir da operação de
    # crossover realizada entre eles. O crossover é feito com divisão central.
    ##
    def crossover(self, cromossomo1, cromossomo2):
        if len(cromossomo1) % 2 != 0:
            cromossomo1 = "0" + cromossomo1
        if len(cromossomo2) % 2 != 0:
            cromossomo2 = "0" + cromossomo2
        if len(cromossomo1) > len(cromossomo2):
            digitosExtras = len(cromossomo1) - len(cromossomo2)
            cromossomo2 = ("0" * digitosExtras) + cromossomo2
        if len(cromossomo2) > len(cromossomo1):
            digitosExtras = len(cromossomo2) - len(cromossomo1)
            cromossomo1 = ("0" * digitosExtras) + cromossomo1

        parte1 = cromossomo1[0:int(len(cromossomo1)/2)]
        parte2 = cromossomo2[int(len(cromossomo2)/2):]
        novoCromossomo = str(parte1) + str(parte2)

        return novoCromossomo

    ##
    # Realiza a mutação de cada um dos genes do nosso cromossomo de acordo com
    # uma taxa específica.
    ##
    def mutation(self, cromossomo, tMutacao):
        lgenes = list(cromossomo)

        for i in range(len(cromossomo)):
            sorteio = random.random()
            if sorteio <= tMutacao:
                if lgenes[i] == "0":
                    lgenes[i] = "1"
                else:
                    lgenes[i] = "0"

        cromossomo = "".join(lgenes)

        return cromossomo

    ##
    # Implementa o conceito de elitismo, inserindo na população nova uma
    # quantidade pré determinada de novos indivíduos correspondentes ao melhor
    # indivíduo da população anterior.
    ##
    def elitismo(self, populacao, tElitismo):
        novaPopulacao = []

        melhorIndividuo = self.getMelhorIndividuo(populacao)
        numeroRepeticoes = int(len(populacao) * tElitismo)

        for i in range(numeroRepeticoes):
            novaPopulacao.append(melhorIndividuo[0])

        return novaPopulacao

    ##
    # Essa rotina recebe uma população de indivíduos, aplica as operações do
    # do algoritmo genético a cada um deles, gerando uma nova população de
    # indivíduos com a mesma quantidade de elementos da população inicial.
    ##
    def geraNovaPopulacao(self, populacaoInicial, tMutation, tElitismo):
        novaPopulacao = self.elitismo(populacaoInicial, tElitismo)

        while len(novaPopulacao) < len(populacaoInicial):
            i1 = random.randint(0, len(populacaoInicial) - 1)
            i2 = random.randint(0, len(populacaoInicial) - 1)
            selecionado1 = populacaoInicial[i1]
            selecionado2 = populacaoInicial[i2]
            individuoMaisApto1 = self.selecionaIndividuo(selecionado1, selecionado2)

            i1 = random.randint(0, len(populacaoInicial) - 1)
            i2 = random.randint(0, len(populacaoInicial) - 1)
            selecionado1 = populacaoInicial[i1]
            selecionado2 = populacaoInicial[i2]
            individuoMaisApto2 = self.selecionaIndividuo(selecionado1, selecionado2)

            novoIndividuo = self.crossover(individuoMaisApto1, individuoMaisApto2)
            filho = self.mutation(novoIndividuo, tMutation)

            novaPopulacao.append(filho)

        return novaPopulacao

    ##
    # Verifica dentro da população de cromossomos qual é o indivíduo que possui
    # a melhor nota de aptidão. Retorna o cromossomo com melhor aptidão.
    ##
    def getMelhorIndividuo(self, populacao):
        melhorIndividuo = self.fitness(populacao[random.randint(0, len(populacao) - 1)])

        for i in populacao:
            individuo = self.fitness(i)

            if individuo[1] > melhorIndividuo[1]:
                melhorIndividuo = individuo

        return melhorIndividuo


    ##
    # Executa o algoritmo genético.
    ##
    def runAG(self, nGeracoes):
        self.populacao = self.criaPopulacao(self.tPopulacao, self.qtdGenes)
        for i in range(nGeracoes):
            melhorIndividuo = self.getMelhorIndividuo(self.populacao)
            self.populacao = self.geraNovaPopulacao(self.populacao, self.tMutacao, self.tElitismo)

        return melhorIndividuo